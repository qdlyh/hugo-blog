[{"categories":null,"content":"项目里有个上拉加载数据的需求，就造了一个上拉加载下拉刷新的轮子，当然这里只说手势滑动事件，滑动到最顶和最底部动画，参考了swiper.js \u003ctemplate\u003e \u003cdiv id=\"pullScrollCell\"\u003e \u003cdiv id=\"touch\"\u003e \u003cdiv\u003e内容\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e data() { return { startX: '', startY: '', limitY: 0, } } mounted() { document.querySelector('#pullScrollCell').addEventListener('scroll', this.debounce(this.pullUpReload, 600)); //设置防抖防止重复触发 document.querySelector('#touch').addEventListener('touchstart', this.touchstart); //收拾开始 document.querySelector('#touch').addEventListener('touchmove', this.touchmove); //手势移动 document.querySelector('#touch').addEventListener('touchend', this.touchend); //手势结束 } methods: { //防抖 debounce(fn, delay) { let timer = null return () =\u003e { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, delay) } }, //手势开始 touchstart(e) { // e.preventDefault() //阻止默认事件 this.startX=e.changedTouches[0].pageX; this.startY=e.changedTouches[0].pageY; }, /* 手势移动中 touchmove的最后坐标减去touchstart的起始坐标， X的结果如果正数，则说明手指是从左往右划动；X的结果如果负数， 则说明手指是从右往左划动；Y的结果如果正数，则说明手指是从上往下划动；Y的结果如果负数， 则说明手指是从下往上划动。 */ touchmove(e) { // e.preventDefault() //阻止默认事件 letscrollTop=Math.ceil(document.querySelector('#pullScrollCell').scrollTop); letmoveEndX=e.changedTouches[0].pageX; letmoveEndY=e.changedTouches[0].pageY; letX=moveEndX-this.startX; letY=moveEndY-this.startY; //向右 if (Math.abs(X) \u003eMath.abs(Y) \u0026\u0026X\u003e0) { // console.log('向左'); } //向左 if (Math.abs(X) \u003eMath.abs(Y) \u0026\u0026X\u003c0) { // console.log('向右'); } //向上 if (Math.abs(Y) \u003eMath.abs(X) \u0026\u0026Y\u003e0) { // console.log('向上'); if (scrollTop==0) { e.preventDefault() //阻止默认事件(微信上拉刷新会触发微信默认事件，导致不能调用刷新加载) } this.limitY=Math.min(Y, 100) //向上滑动动画最大100 document.querySelector('#touch').style = `transition: all 0ms ease 0s; transform: translate3d(0px, ${this.limitY}px, 0px)`; } //向下 if (Math.abs(Y) \u003eMath.abs(X) \u0026\u0026Y\u003c0) { // console.log('向下'); this.limitY=Math.max(Y, -100) //向下滑动动画最大-100 document.querySelector('#touch').style = `transition: all 0ms ease 0s; transform: translate3d(0px, ${this.limitY}px, 0px)`; } }, //手势结束 touchend(e) { letscrollTop=Math.ceil(document.querySelector('#pullScrollCell').scrollTop); //滚动条到顶部的位置 document.querySelector('#touch').style = `transition: all 300ms ease 0s; transform: translate3d(0px, 0px, 0px)`; if (scrollTop==0\u0026\u0026this.limitY\u003e=60) { 滚动条在顶部并且下拉值大于60，触发 } }, } \u003cscript\u003e ","date":"2024-07-01","objectID":"/js%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%88%A4%E6%96%AD%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E6%96%B9%E5%90%91/:0:0","tags":null,"title":"Js手势滑动事件（判断上下左右方向）","uri":"/js%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E5%88%A4%E6%96%AD%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E6%96%B9%E5%90%91/"},{"categories":null,"content":"原理：利用canvas来实现，将图片绘制到canvas上，然后canvas转图片时，微信提供的一个方法wx.canvasToTempFilePath(Object object, Object this)，此方式可以指定生成图片的质量 注意：quality设置只对jpg格式的图片有效，使用时要将fileType设置为“jpg”， 此举可能会导致其它格式的图片变为jpg格式 xwml //xwml \u003cview\u003e \u003cbutton bindtap=\"chooseImage\"\u003e选择图片\u003c/button\u003e \u003c/view\u003e \u003c!-- 展示压缩后的图片 --\u003e \u003cview style=\"display: flex;justify-content: center;flex-direction: column\"\u003e \u003cimage mode=\"widthFix\" src=\"{{imagePath}}\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cbutton wx:if=\"{{imagePath.length\u003e0}}\" bindtap=\"save\"\u003e点击下载压缩后的图片\u003c/button\u003e \u003c!-- 用来渲染的canvas --\u003e \u003ccanvas canvas-id='attendCanvasId' class='myCanvas' style='width:{{cWidth}}px;height:{{cHeight}}px;position: fixed;top: -9999px;left: -9999px;'\u003e\u003c/canvas\u003e js Page({ /** * 页面的初始数据 */ data: { imagePath: '', quality: 0.2, cWidth: 0, cHeight: 0, timer: null }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { }, /** * 选项添加图片事件 */ chooseImage: function (e) { var that = this; wx.chooseImage({ sizeType: ['compressed'], //可选择原图或压缩后的图片 sourceType: ['album', 'camera'], //可选择性开放访问相册、相机 success: result =\u003e { wx.getImageInfo({ src: result.tempFilePaths[0], success: function (res) { console.log(res.width, res.height) that.setData({ cWidth: res.width, cHeight: res.height }, () =\u003e { // setData引起的页面渲染完成之后的回调函数 // setData渲染是异步的 canvasToTempFilePath的时候canvas的大小可能还没有被重新设置 that.getCanvasImg(result.tempFilePaths, res.width, res.height, that.data.quality); }) } }) } }) }, /** * 质量压缩 */ getCanvasImg(tempFilePaths, canvasWidth, canvasHeight, quality) { var that = this; const ctx = wx.createCanvasContext('attendCanvasId'); ctx.clearRect(0, 0, canvasWidth, canvasHeight); let pixelRatio = wx.getSystemInfoSync().pixelRatio ctx.drawImage(tempFilePaths[0], 0, 0, canvasWidth, canvasHeight); ctx.draw(false, function () { that.data.timer = setTimeout(() =\u003e { wx.canvasToTempFilePath({ canvasId: 'attendCanvasId', fileType: 'jpg', quality: quality, destWidth: canvasWidth, destHeight: canvasHeight, success: function success(res) { clearTimeout(that.data.timer) that.setData({ imagePath: res.tempFilePath }); }, fail: function (e) { clearTimeout(that.data.timer) wx.showModal({ title: '提示', content: JSON.stringify(e), }) } }); }, 500) }); }, /** * 图片保存到相册 */ save(e) { let that = this; wx.saveImageToPhotosAlbum({ filePath: that.data.imagePath, success: function (res) { console.log('图片已保存'); }, fail: function (res) { console.log('保存失败'); } }) } }) ","date":"2024-07-01","objectID":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E9%9D%9E%E8%A3%81%E5%89%AA/:0:0","tags":null,"title":"微信小程序压缩图片，压缩图片质量非裁剪","uri":"/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E8%B4%A8%E9%87%8F%E9%9D%9E%E8%A3%81%E5%89%AA/"},{"categories":null,"content":"在写前端页面中，经常会在浏览器运行HTML页面，从本地文件夹中直接打开的一般都是file协议，当代码中存在http或https的链接时，HTML页面就无法正常打开，为了解决这种情况，需要在在本地开启一个本地的服务器。 本文是利用node.js中的http-server，开启本地服务，步骤如下： 1.下载node.js 官网地址：https://nodejs.org 下载完成后在命令行输入命令$node -v以及$npm -v检查版本，确认是否安装成功。 2.下载http-server 在终端输入： $ npm install http-server -g 3.开启 http-server服务 终端进入目标文件夹，然后在终端输入： $ http-server -c-1 （⚠️只输入http-server的话，更新了代码后，页面不会同步更新） ","date":"2024-07-01","objectID":"/%E4%BD%BF%E7%94%A8http-server%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":null,"title":"使用http Server开启一个本地服务器","uri":"/%E4%BD%BF%E7%94%A8http-server%E5%BC%80%E5%90%AF%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":null,"content":"项目上有个需求，需要缓存已打开的页面，同时关闭 tab 的时候清除缓存。 ","date":"2024-07-01","objectID":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/:0:1","tags":null,"title":"Vue2通过keep Alive设置页面TABS业务缓存","uri":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"总体思路 1.在 vue 方法里keep-alive的include设置需要缓存页面的name可以判断页面是否已缓存（include可字符串可数组）这里通过数组方式进行 2.设置文件里的name和路由里的name（保持一致） 3.在进入页面之后获取该页面路由放置到include数组里 4.数组过滤重复进入已缓存的页面name 5.点击 tab 关闭标签的时候删除include数组缓存中的name ","date":"2024-07-01","objectID":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/:0:2","tags":null,"title":"Vue2通过keep Alive设置页面TABS业务缓存","uri":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"过程中遇到问题 1.进入已缓存的页面include数组又重新push了已缓存的页面name导致缓存失败。 解决方法通过设置Array.from(new Set())过滤掉重复的数据即可 2.详情页面根据 key 改变的页面没有更新数据。例如 url 为/xxx?id=7c65f58 解决方法通过设置 key \u003crouter-view :key=\"$route.query.id\"\u003e\u003c/router-view\u003e //App.vue \u003ckeep-alive :include=\"$store.state.historyList.cachedHistoryNames\"\u003e \u003crouter-view :key=\"$route.query.id\"\u003e\u003c/router-view\u003e \u003c/keep-alive\u003e //state.js historyList: { historyNave: [{ //保存详情页历史记录 title: '首页', cachedName: 'home', href: '/home' }], cachedHistoryNames: [], //缓存页面路由 } //main.js router.afterEach((to) =\u003e { //保存详情页浏览历史记录 setTimeout(() =\u003e { if (to.meta.title) { //判断该导航是否已存在新增的url，不存在才插入url let path= window.location.hash.split('#')[1]; letisHave=store.state.historyList.historyNave.every((item) =\u003e { if (item.href !==path) { return true; } }) if (isHave) { store.state.historyList.historyNave.push({ \"title\": to.meta.title, //tab的名称 \"cachedName\": to.name, //缓存页面的name \"href\": path //点击tab转跳的地址 }); } } store.state.historyList.cachedHistoryNames.push(to.name) //缓存页面 store.state.historyList.cachedHistoryNames=Array.from(new Set(store.state.historyList.cachedHistoryNames)) //删除缓存重复数据name }); }); //顶部导航组件 methods: { //删除缓存 deleteHistory(item, index) { this.historyList.splice(index, 1); //删除历史导航 this.cachedHistoryNames.forEach((element, i) =\u003e { //删除历史导航缓存 if (element===item.cachedName) { this.cachedHistoryNames.splice(i, 1) } } } }, ","date":"2024-07-01","objectID":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/:0:3","tags":null,"title":"Vue2通过keep Alive设置页面TABS业务缓存","uri":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2tabs%E4%B8%9A%E5%8A%A1%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"一直以来移动端的项目都有一种优化上的需求，那就是前进页面拿最新的数据，后退页面即缓存页面。 ","date":"2024-07-01","objectID":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/:0:1","tags":null,"title":"Vue2通过keep Alive设置页面缓存","uri":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"总体思路 1.在 vue 方法里 keep-alive 的 include 设置需要缓存页面的 name 可以判断页面是否已缓存（include 可字符串可数组）这里通过数组方式进行 2.设置文件里的 name 和路由里的 name（保持一致） 3.router.js 路由文件中设置两个值 keepAlive 和 deleteCachedName。需要缓存的设置 keepAlive:true，不需要的直接设置 deleteCachedName:需要删除的缓存 name 4.新增/删除 include 数组缓存中的 name 5.返回上一页自动滑动到上次滚动条的位置 //App.vue \u003ckeep-alive :include=\"$store.state.cachedRouteNames\"\u003e \u003crouter-view :key=\"$route.query.id\"\u003e\u003c/router-view\u003e \u003c/keep-alive\u003e //router.js { path: '/home', name: 'home', meta: { title: '我需要缓存页面', keepAlive: true, //页面需要缓存 }, component: () =\u003eimport('@/views/home/index.vue') }, { path: '/goHome', name: 'goHome', meta: { title: '删除缓存', deleteCachedName: 'home', //删除home页面需要缓存 }, component: () =\u003eimport('@/views/goHome/goHome.vue') } //state.js const state = { cachedRouteNames: [], //缓存页面路由 cachedRouteScroll:null //缓存页面滚动条位置 }; export default state //mutations.js const mutations = { /\\* - 设置缓存 - 添加缓存，需要配置在组件里添加 name 以及路由里写上对应组件的 name (name 格式 xx-xx (父组件 name-当前 name) 用\"-\"区分开来) - 删除缓存，需要配置（以缓从组件）上一个组件里添加\"deleteCachedName:删除的组件 name\" (例如 A ——\u003e B 删除以缓存的组件 B，即在 A 的路由 meta 里添加 deleteCachedName:B) _/ SetcachedRouteNames(state,{ action, route }) { const methods= { 'add': () =\u003e { //添加缓存 state.cachedRouteNames.push(route) state.cachedRouteNames=Array.from(new Set(state.cachedRouteNames)) //删除缓存重复数据 name }, 'delete': () =\u003e { //删除缓存 state.cachedRouteNames.splice(state.cachedRouteNames.findIndex((e) =\u003e { return e === route}),1) } } methods[action]() }, /_ *设置缓存滚动条 set 记录滚动条位置，to 滚动到记录位置。set 和 to 调用方法是一样的 *to 一般用在页面初始化 DOM 已加载完进行调用 this.$store.commit('SetcachedRouteScroll', { action: 'to', name: '' }) *set一般用在页面离开进行调用 this.$store.commit('SetcachedRouteScroll', { action: 'set', name: '' }) this.$store.commit('SetcachedRouteScroll', { action: 'to', name: '滚动条模块的name或id，需要加上.或#' }) this.$store.commit('SetcachedRouteScroll', { action: 'to', name: '.class' }) this.$store.commit('SetcachedRouteScroll', { action: 'to', name: '#id' }) \\*/ SetcachedRouteScroll(state,{ action, name }) { const methods= { 'set': () =\u003e { //记录滚动条位置 state.cachedRouteScroll= document.querySelector(name).scrollTop; // console.log(state.cachedRouteScroll) }, 'to': () =\u003e { //滚动到记录位置 document.querySelector(name).scrollTop = state.cachedRouteScroll; // console.log(state.cachedRouteScroll) } } methods[action]() }, }; export default mutations //main.js /\\* - 页面转跳之后 - 添加缓存，需要配置在组件里添加 name 以及路由里写上对应组件的 name (name 格式 xx-xx (父组件 name-当前 name) 用\"-\"区分开来) - 删除缓存，需要配置（以缓从组件）上一个组件里添加\"deleteCachedName:删除的组件 name\" (例如 A ——\u003e B 删除以缓存的组件 B，即在 A 的路由 meta 里添加 deleteCachedName:B) \\*/ router.afterEach((to, from, next) =\u003e { if (to.meta.keepAlive) { //页面缓存 store.commit('SetcachedRouteNames', { action: 'add', route: to.name }) } if (to.meta.deleteCachedName) { //删除缓存 store.commit('SetcachedRouteNames', { action: 'delete', route: to.meta.deleteCachedName }) } }); //组件 activated() { //滑动到记录滚动条的位置 this.$store.commit('SetcachedRouteScroll', { action: 'to', name: '#pullScrollCell' }) }, methods: { //转跳页面，记录当前滚动条 go(item) { this.$store.commit('SetcachedRouteScroll', { action: 'set', name: '#pullScrollCell' }) this.$router.push({ path: '/details', query: { id:xxx, } }) }, } ","date":"2024-07-01","objectID":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/:0:2","tags":null,"title":"Vue2通过keep Alive设置页面缓存","uri":"/vue2%E9%80%9A%E8%BF%87keep-alive%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/"},{"categories":null,"content":"1.下载nvm github最新版本下载: https://github.com/coreybutler/nvm-windows/releases 2.nvm的使用方法 1.安装最新版node： nvm install latest 2.安装指定版本node： nvm install 14.15.0 3.查看已安装的node版本: nvm ls / nvm list 4.使用指定版本node： nvm use 14.15.0 不指定具体版本即为现有的最新版本nvm use 14 6.卸载指定版本node： nvm uninstall 14.15.0 ","date":"2024-07-01","objectID":"/window%E4%B8%8A%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/:0:0","tags":null,"title":"Window上使用NVM进行管理node版本","uri":"/window%E4%B8%8A%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86node%E7%89%88%E6%9C%AC/"},{"categories":null,"content":"以下是创建第一篇文章的方法: hugo new posts/first_post.md 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 在本地启动网站 hugo serve 请访问 http://localhost:1313 预览尚未正式发布的内容 hugo serve -D Hugo 的运行环境 这个命令会启动一个本地服务器，生成并展示包含草稿文章的整个网站。这在开发阶段非常有用，因为它允许你预览尚未正式发布的内容。 hugo serve 的默认运行环境是 development, 而 hugo 的默认运行环境是 production. 由于本地 development 环境的限制, 评论系统, CDN 和 fingerprint 不会在 development 环境下启用. 你可以使用 hugo serve -e production 命令来开启这些特性. ","date":"2024-07-01","objectID":"/hugo%E4%BD%BF%E7%94%A8/:0:0","tags":null,"title":"Hugo使用","uri":"/hugo%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"构建网站 hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. ","date":"2024-07-01","objectID":"/hugo%E4%BD%BF%E7%94%A8/:0:1","tags":null,"title":"Hugo使用","uri":"/hugo%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"测试文章 该博客模板是hugo主题是LoveIt 搭建博客的原因是平时写一些工作上的笔记，或者自己学习的技术记录方便阅读回顾！ 其实之前也有用过vue+Express搭建前后端的框架，不过阿里云一年比一年贵，已经不打算续费，改用hugo进行搭建 😂 ","date":"2024-03-01","objectID":"/first_post/:0:0","tags":null,"title":"First_post","uri":"/first_post/"},{"categories":null,"content":"大家好，我是lyh 该博客模板是hugo主题是LoveIt 搭建博客的原因是平时写一些工作上的笔记，或者自己学习的技术记录方便阅读回顾！ 其实之前也有用过vue+Express搭建前后端的框架，不过阿里云一年比一年贵，已经不打算续费，改用hugo进行搭建 😂 ","date":"2024-03-01","objectID":"/about/about/:0:0","tags":null,"title":"About","uri":"/about/about/"}]